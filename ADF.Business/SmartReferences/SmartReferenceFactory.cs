//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated using Tobago MDA.
//     Model           : SmartReferences
//     Template        : Business Object Factory.tpl
//     Runtime Version : $Version$
//     Generation date : 26-9-2007 13:35:39
//
//     Changes to this file may cause incorrect behavior and may be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using Adf.Base.Domain;
using Adf.Core.Data;
using Adf.Core.Domain;
using Adf.Core.Identity;
using Adf.Core.State;
using Adf.Data.Search;
using Adf.Data.SmartReferences;

namespace Adf.Business.SmartReferences
{
    /// <summary>
    /// Represents SmartReference Factory that provides functionality for various factory operations.
    /// </summary>
    public static class SmartReferenceFactory
    {
        private static string Key(Type type)
        {
            return string.Format("Adf.SmartReferences.Cache<{0}>", type.Name);
        }

        private static string Key<T>() where T : References
        {
            return Key(typeof(T));
        }

        private static ISmartReference Create(Type type)
        {
            var genericType = typeof (SmartReference<>).MakeGenericType(new[] {type});

            return Activator.CreateInstance(genericType) as ISmartReference;
        }

        private static ISmartReference Create(Type type, IInternalState state)
        {
            var genericType = typeof (SmartReference<>).MakeGenericType(new[] {type});

            return Activator.CreateInstance(genericType, state) as ISmartReference;
        }


        #region CodeGuard(Method New)

        /// <summary>
        /// Creates and returns a SmartReference.
        /// </summary>
        /// <typeparam name="T">The supplied <see cref="Type"/>.</typeparam>
        /// <returns>The newly created SmartReference.</returns>
        public static SmartReference<T> New<T>()
        {
            return (SmartReference<T>) New(typeof(T));
        }

        /// <summary>
        /// Creates and returns an <see cref="ISmartReference"/> using the supplied <see cref="Type"/>.
        /// </summary>
        /// <param name="type">The supplied <see cref="Type"/>.</param>
        /// <returns>The newly created <see cref="ISmartReference"/>.</returns>
        public static ISmartReference New(Type type)
        {
            return Create(type, SmartReferenceGateway.New(type.Name));
        }

        #endregion CodeGuard(Method New)

        #region CodeGuard(Method List)

        /// <summary>
        /// Returns a list of type DomainCollection with the supplied
        /// array of <see cref="IInternalState"/> added to it.
        /// </summary>
        /// <param name="states">The supplied array of <see cref="IInternalState"/>.</param>
        /// <returns>A DomainCollection.</returns>
        private static DomainCollection<ISmartReference> List(Type type, IEnumerable<IInternalState> states)
        {
            var list = new DomainCollection<ISmartReference>();

            var genericType = typeof(SmartReference<>).MakeGenericType(new[] {type});

            foreach (var state in states)
            {
                list.Add(Activator.CreateInstance(genericType, state) as ISmartReference);
            }

            return list;
        }

        #endregion CodeGuard(Method List)

        #region CodeGuard(Method Search)
        /// <summary>
        /// Searches and Returns a DomainCollection for the supplied search object.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="searchObject">The search object.</param>
        /// <returns>A DomainCollection.</returns>
        public static DomainCollection<SmartReference<T>> Search<T>(ISearchObject searchObject)
        {
            return new DomainCollection<SmartReference<T>>(Search(typeof(T), searchObject).Select(s => s as SmartReference<T>));
        }

        public static DomainCollection<ISmartReference> Search(Type type, ISearchObject searchObject)
        {
            return List(type, SmartReferenceGateway.Search(searchObject.GetParameters()));
        }

        #endregion CodeGuard(Method Search)

        #region CodeGuard(Method Get)
        /// <summary>
        /// Returns a SmartReference for the supplied <see cref="ID"/>
        /// where T is <see cref="References"/>.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="id">The supplied <see cref="ID"/>.</param>
        /// <returns>A SmartReference.</returns>
        public static SmartReference<T> Get<T>(ID id) where T : References
        {
            return Get(typeof(T), id) as SmartReference<T>;
        }

        /// <summary>
        /// Returns an <see cref="ISmartReference"/> for the supplied <see cref="ID"/>
        /// and <see cref="Type"/>.
        /// </summary>
        /// <param name="id">The <see cref="ID"/>.</param>
        /// <param name="type">The <see cref="Type"/>.</param>
        /// <returns>An <see cref="ISmartReference"/>.</returns>
        public static ISmartReference Get(Type type, ID id)
        {
            return GetAll(type).FirstOrDefault(sr => sr.Id == id) ?? Create(type);
        }

        /// <summary>
        /// Returns a DomainCollection of all SmartReferences of type T
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static DomainCollection<SmartReference<T>> GetAll<T>() where T : References
        {
            return new DomainCollection<SmartReference<T>>(GetAll(typeof (T)).Select(s => s as SmartReference<T>));
        }

        /// <summary>
        /// Returns a DomainCollection of all SmartReferences of type T
        /// </summary>
        /// <returns></returns>
        public static DomainCollection<ISmartReference> GetAll(Type type)
        {
            return StateManager.Application.GetOrSetValue(Key(type), () => List(type, SmartReferenceGateway.GetByType(type.Name)));
        }

        #endregion CodeGuard(Method Get)

        #region CodeGuard(Method Remove)
        /// <summary>
        /// Removes the supplied <see cref="ISmartReference"/>.
        /// </summary>
        /// <param name="smartreference">The <see cref="ISmartReference"/>.</param>
        /// <returns>True if the removal is successful, false otherwise.</returns>
        public static bool Remove(ISmartReference smartreference)
        {
            var domainobject = smartreference as DomainObject;

            ClearCache(smartreference.GetType());

            return domainobject == null || SmartReferenceGateway.Remove(domainobject.GetState());
        }

        #endregion CodeGuard(Method Remove)

        #region CodeGuard(Method Save)
        /// <summary>
        /// Persists the supplied SmartReference.
        /// </summary>
        /// <param name="smartreference">The supplied SmartReference.</param>
        /// <returns>True if the saving is successful, false otherwise.</returns>
        public static bool Save(ISmartReference smartreference)
        {
            var domainobject = smartreference as DomainObject;

            if (domainobject.IsNullOrEmpty()) throw new ArgumentNullException("smartreference");

            if (domainobject.IsAltered)
            {
                if (!SmartReferenceGateway.Save(domainobject.GetState())) return false;

                ClearCache(smartreference.GetType());
            }

            return true;
        }

        #endregion CodeGuard(Method Save)

        public static SmartReference<T> GetEmpty<T>()
        {
            return new SmartReference<T>();
        }

        public static void ClearCache(Type type)
        {
            if (StateManager.Application.Has(Key(type))) StateManager.Application.Remove(Key(type));
        }
        
        public static void ClearCache<T>() where T : References
        {
            if (StateManager.Application.Has(Key<T>())) StateManager.Application.Remove(Key<T>());
        }
    }
}
